// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: data.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addBook = `-- name: AddBook :exec
INSERT INTO books (title, description, num_copy) 
VALUES ($1, $2, $3)
RETURNING id
`

type AddBookParams struct {
	Title       string
	Description pgtype.Text
	NumCopy     int32
}

// Usecase: add a new book
func (q *Queries) AddBook(ctx context.Context, arg AddBookParams) error {
	_, err := q.db.Exec(ctx, addBook, arg.Title, arg.Description, arg.NumCopy)
	return err
}

const addBookAuthor = `-- name: AddBookAuthor :exec
INSERT INTO book_authors (book_id, author_id) 
VALUES ($1, $2)
`

type AddBookAuthorParams struct {
	BookID   int32
	AuthorID int32
}

func (q *Queries) AddBookAuthor(ctx context.Context, arg AddBookAuthorParams) error {
	_, err := q.db.Exec(ctx, addBookAuthor, arg.BookID, arg.AuthorID)
	return err
}

const borrowBook = `-- name: BorrowBook :exec
INSERT INTO borrowed_books (user_id, book_id) 
VALUES ($1, $2)
`

type BorrowBookParams struct {
	UserID int32
	BookID int32
}

// Usercase: borrow a book
func (q *Queries) BorrowBook(ctx context.Context, arg BorrowBookParams) error {
	_, err := q.db.Exec(ctx, borrowBook, arg.UserID, arg.BookID)
	return err
}

const deleteBook = `-- name: DeleteBook :exec
DELETE FROM books
WHERE id = $1
`

// Usercase: delete a book
func (q *Queries) DeleteBook(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteBook, id)
	return err
}

const editBook = `-- name: EditBook :exec
UPDATE books
SET title = $2, description = $3, num_copy = $4
WHERE id = $1
`

type EditBookParams struct {
	ID          int32
	Title       string
	Description pgtype.Text
	NumCopy     int32
}

// Usercase: edit book details
func (q *Queries) EditBook(ctx context.Context, arg EditBookParams) error {
	_, err := q.db.Exec(ctx, editBook,
		arg.ID,
		arg.Title,
		arg.Description,
		arg.NumCopy,
	)
	return err
}

const listBooksWithAuthors = `-- name: ListBooksWithAuthors :many
SELECT b.id, b.title, b.description, a.name AS author_name 
FROM books b
JOIN book_authors ba ON b.id = ba.book_id
JOIN authors a ON ba.author_id = a.id
`

type ListBooksWithAuthorsRow struct {
	ID          int32
	Title       string
	Description pgtype.Text
	AuthorName  string
}

// Usercase: list all books with their authors (So user can borrow)
// TODO: it may be to big
func (q *Queries) ListBooksWithAuthors(ctx context.Context) ([]ListBooksWithAuthorsRow, error) {
	rows, err := q.db.Query(ctx, listBooksWithAuthors)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListBooksWithAuthorsRow
	for rows.Next() {
		var i ListBooksWithAuthorsRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.AuthorName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const returnBook = `-- name: ReturnBook :exec
UPDATE borrowed_books
SET returned_at = CURRENT_TIMESTAMP
WHERE user_id = $1 AND book_id = $2 AND returned_at IS NULL
`

type ReturnBookParams struct {
	UserID int32
	BookID int32
}

// Usercase: return a book
func (q *Queries) ReturnBook(ctx context.Context, arg ReturnBookParams) error {
	_, err := q.db.Exec(ctx, returnBook, arg.UserID, arg.BookID)
	return err
}
